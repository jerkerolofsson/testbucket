@attribute [Authorize()]
@using Plotly.Blazor.LayoutLib
@using System.Diagnostics
@using TestBucket.Components.Reporting.Controllers
@using TestBucket.Components.Reporting.Helpers
@using TestBucket.Contracts.Appearance.Models
@using TestBucket.Domain.Appearance
@using TestBucket.Domain.Insights
@using TestBucket.Domain.Insights.Model
@using TestBucket.Domain.Testing.Aggregates
@inject TestBrowser testBrowser
@inject TestCaseEditorController testCaseEditorController
@inject TestExecutionController testExecutionController
@inject InsightsController controller
@inject ThemingService themingService
@inject AuthenticationStateProvider authenticationStateProvider
@inject ITestBucketThemeManager testBucketThemeManager
@inject IStringLocalizer<SharedStrings> loc
@inject IStringLocalizer<InsightStrings> insightLoc

<MudPaper Elevation="2" Class="tb-tile">
    <MudStack Spacing="0" Class="tb-insights-chart">
        <MudStack Row Style="width: 100%" AlignItems="AlignItems.Center">
            <MudText Typo="Typo.h6">@Title</MudText>
            <MudSpacer />

            <MudToggleGroup T="ChartType" Value="@_chartType" ValueChanged="OnChartTypeChanged" Color="Color.Surface"> 
                <MudToggleItem Value="ChartType.Donut"><MudIcon Icon="@Icons.Material.Rounded.DonutLarge" Size="Size.Small" /></MudToggleItem>
                <MudToggleItem Value="ChartType.Pie"><MudIcon Icon="@Icons.Material.Rounded.PieChart" Size="Size.Small" /></MudToggleItem>
                <MudToggleItem Value="ChartType.Bar"><MudIcon Icon="@Icons.Material.Rounded.BarChart" Size="Size.Small" /></MudToggleItem>
                <MudToggleItem Value="ChartType.Line"><MudIcon Icon="@Icons.Material.Rounded.StackedLineChart" Size="Size.Small" /></MudToggleItem>
            </MudToggleGroup>

        </MudStack>
        @if (_layout is not null && _results is not null && _config is not null)
        {
            <PlotlyChart class="tb-chart result-chart" @ref="_chart" @bind-Config="_config" @bind-Layout="_layout" @bind-Data="_data" />

            @if(Spec is not null)
            {
                if (Spec.ShowLegend)
                {
                    <div class="legend">
                        @foreach (var legendItem in _legendTitleColorMap)
                        {
                            var color = legendItem.Value;
                            <div class="item">
                                <ColorCell Color="@color"/>
                                @insightLoc[legendItem.Key]
                            </div>
                        }
                    </div>
                }
                if(Spec.ShowDataTable)
                {
                    <InsightsDataTable Results="@_results"/>
                }
            }
        }
        else
        {
            <MudSkeleton SkeletonType="SkeletonType.Rectangle" Class="tb-chart-skeleton"/>
        }
    </MudStack>
</MudPaper>

@code {
    [Parameter] public string Title { get; set; } = "";
    [Parameter] public ChartType ChartType { get; set; } = ChartType.Line;
    [Parameter] public bool ShowLegend { get; set; } = false;
    [Parameter] public InsightsVisualizationSpecification? Spec { get; set; }
    [CascadingParameter] public TestProject? Project { get; set; }

    private ChartType _chartType = ChartType.Line;

    private PlotlyChart? _chart;
    private Config? _config = new Config()
    {
        Responsive = true
    };
    private Layout? _layout;
    private Dictionary<string, string> _legendTitleColorMap = [];

    // Using of the interface IList is important for the event callback!
    private IList<ITrace> _data = new List<ITrace>();

    private InsightsData<string, double>? _results;

    private async Task OnChartTypeChanged(ChartType chartType)
    {
        _chartType = chartType;
        await BuildChartData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(_results is null && Spec is not null)
        {
            _results = await controller.GetDataAsync(Project?.Id, Spec.DataQueries[0]);
            _chartType = ChartType;

            _layout = PlotlyChartBuilder.GetDefaultLayout(themingService.IsDarkMode);
            _layout.AutoSize = true;
            _layout.ShowLegend = false;

            _layout.XAxis = [
                new XAxis {
                ShowTickLabels = true
            }
            ];

            _layout.Margin = new Plotly.Blazor.LayoutLib.Margin
            {
                L = 0,
                T = 0,
                R = 0,
                B = 0
            };

            if (_results is not null)
            {
                await BuildChartData();
                await InvokeAsync(this.StateHasChanged);
            }
        }
    }

    protected override void OnParametersSet()
    {
        _results = null;
    }

    private async Task<List<string>> GetColorwayAsync()
    {
        _legendTitleColorMap.Clear();

        var authState = await authenticationStateProvider.GetAuthenticationStateAsync();
        var theme = await testBucketThemeManager.GetCurrentThemeAsync(authState.User);
        List<string> colorway = [];
        ThemePalette palette = theme.ChartPalette;
        if (_results is not null)
        {
            var colors = new ChartColorizer(palette);
            _legendTitleColorMap = colors.GetColorway(Spec, _results);
            colorway = _legendTitleColorMap.Values.ToList();
        }
        else
        {
            colorway = palette.Colors.Select(c => c.ToString(ColorOutputFormats.HexA)).ToList();
        }
        return colorway;
    }

    private async Task BuildChartData()
    {
        Debug.Assert(_layout != null);
        if (_layout is null || _results is null)
        {
            return;
        }

        var colorway = await GetColorwayAsync();

        _data.Clear();
        _layout.Annotations = [];
        _layout.Colorway = null;
        if (_chartType == ChartType.Line)
        {
            int colorWayIndex = 0;
            foreach (var series in _results.Series)
            {
                string? color = null;
                if(colorway.Count > 0)
                {
                    color = colorway[colorWayIndex];
                    colorWayIndex++;
                    if(colorWayIndex >= colorway.Count)
                    {
                        colorWayIndex = 0;
                    }
                }
                var scatter = new Scatter()
                {
                    Name = series.Name.ToString(),
                    X = new List<object>(),
                    Y = new List<object>(),
                    Marker = new Plotly.Blazor.Traces.ScatterLib.Marker
                    {
                        Color = color
                    },
                };
                _data.Add(scatter);

                foreach (var point in series.Data)
                {
                    scatter.X.Add(point.Label.ToString());
                    scatter.Y.Add(point.Value);
                }
            }
        }
        else if (_chartType == ChartType.Bar)
        {
            foreach (var series in _results.Series)
            {
                var scatter = new Bar()
                {
                    Name = series.Name.ToString(),
                    X = new List<object>(),
                    Y = new List<object>()
                };

                if (colorway.Count > 0)
                {
                    scatter.Marker = new Plotly.Blazor.Traces.BarLib.Marker
                    {
                        ColorArray = [..colorway]
                    };
                }

                _data.Add(scatter);

                foreach (var point in series.Data)
                {
                    scatter.X.Add(point.Label.ToString());
                    scatter.Y.Add(point.Value);
                }
            }
        }
        else if (_chartType is ChartType.Pie or ChartType.Donut)
        {
            foreach (var series in _results.Series)
            {

                var pie = new Pie()
                {
                    AutoMargin = true,
                    Sort = false,
                    TextInfo = Plotly.Blazor.Traces.PieLib.TextInfoFlag.None,
                    Name = series.Name.ToString(),
                    Labels = [],
                    Values = []
                };
                if (_chartType == ChartType.Donut)
                { 
                    pie.Hole = 0.8M; 
                }
                _data.Add(pie);

                foreach (var point in series.Data)
                {
                    pie.Labels.Add(point.Label.ToString());
                    pie.Values.Add(point.Value);
                }
            }

            // For pie and donut charts, use the colorway on the layout to define the colors
            // These are ordered by the label so should be correct order
            if (colorway.Count > 0)
            {
                _layout.Colorway = colorway.ToArray();
            }

        }

        if (_chart is not null)
        {
            try
            {
                await _chart.Update(_data, _layout);
                await _chart.React();
            }
            catch { }
        }
    }
}
